- id: 1
  languageId: 1
  coreFramework: "Spring Boot"
  name: "Spring Boot - WEB API REST"
  template: "Template"
  useDB: true
  withGroupId: true
  useCloud: false
  useEurekaServer: false
  isGateway: false
  additionalFiles:
    - fileType: "MainFile"
      fileName: "${majStart(projectName)}Application"
      extension: "java"
      content: |
        package ${groupLink}.${lowerCase(projectName)};

        import io.swagger.v3.oas.models.OpenAPI;
        import io.swagger.v3.oas.models.info.Info; 
        import org.springframework.context.annotation.Bean;
        import org.springframework.boot.SpringApplication;
        import org.springframework.boot.autoconfigure.SpringBootApplication;
        {{#if useEurekaServer}}import org.springframework.cloud.client.discovery.EnableDiscoveryClient;{{/if}}

        {{#if useEurekaServer}}@EnableDiscoveryClient{{/if}}
        @SpringBootApplication
        public class ${majStart(projectName)}Application {
            public static void main(String[] args) {
                SpringApplication.run(${majStart(projectName)}Application.class, args);
            }
        
            @Bean
            public OpenAPI customOpenAPI() {
                return new OpenAPI()
                            .info(new Info().title("${projectName}")
                            .description("${projectDescription}")
                            .version("0.0.1-SNAPSHOT"));
            }
        }
      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}"

    - fileType: "TestFile"
      fileName: "${majStart(projectName)}ApplicationTests"
      extension: "java"
      content: |
        package ${groupLink}.${lowerCase(projectName)};

        import org.junit.jupiter.api.Test;
        import org.springframework.boot.test.context.SpringBootTest;

        @SpringBootTest
        class ${majStart(projectName)}ApplicationTests {

        {{tab}}@Test
        {{tab}}void contextLoads() {
        {{tab}}}

        }
      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/test/java/${groupLinkPath}/${lowerCase(projectName)}/"


    - fileType: "RestResponse"
      fileName: "RestResponse"
      extension: "java"
      content: |
        package ${groupLink}.${lowerCase(projectName)}.dto;

        import java.time.Instant;
        import org.springframework.http.HttpStatus;
        import lombok.Getter;
        import lombok.Setter;

        @Getter
        @Setter
        public class RestResponse<T> {
            private int status;
            private String message;
            private int returnCode;
            private T data;
            private Instant timestamp;

            private RestResponse(int status, String message, int returnCode, T data) {
                this.status = status;
                this.message = message;
                this.returnCode = returnCode;
                this.data = data;
                this.timestamp = Instant.now();
            }

            public static <T> RestResponse<T> buildSuccessResponse(HttpStatus status, String message, T data) {
                int OK = 1;
                return new RestResponse<>(status.value(), message, OK, data);
            }

            public static <T> RestResponse<T> buildErrorResponse(HttpStatus status, String message, T data) {
                int KO = 0;
                return new RestResponse<>(status.value(), message, KO, data);
            }
          }

      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}/dto"
    - fileType: "WebConfig"
      fileName: "WebConfig"
      extension: "java"
      content: |
        package ${groupLink}.${lowerCase(projectName)}.config;

        import org.springframework.context.annotation.Configuration;
        import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
        import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
        import org.springframework.web.servlet.config.annotation.CorsRegistry;

        @Configuration
        public class WebConfig implements WebMvcConfigurer {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                    .allowedOriginPatterns("*")
                    .allowedMethods("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS")
                    .allowedHeaders("*")
                    .allowCredentials(true)
                    .maxAge(3600);
            }
            @Override
            public void addViewControllers(ViewControllerRegistry registry) {
                registry.addRedirectViewController("/", "/swagger-ui/index.html");
            }
        }
      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}/config"

    - fileType: "Exception"
      fileName: "ResourceNotFoundException"
      extension: "java"
      content: |
        package ${groupLink}.${lowerCase(projectName)}.exception;

        public class ResourceNotFoundException extends RuntimeException {
            public ResourceNotFoundException(String message) {
                super(message);
            }
            
            public ResourceNotFoundException(String message, Throwable cause) {
                super(message, cause);
            }
        }
      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}/exception"

    - fileType: "Exception"
      fileName: "InternalServerErrorException"
      extension: "java"
      content: |
        package ${groupLink}.${lowerCase(projectName)}.exception;

        public class InternalServerErrorException extends RuntimeException {
            public InternalServerErrorException(String message) {
                super(message);
            }
            
            public InternalServerErrorException(String message, Throwable cause) {
                super(message, cause);
            }
        }
      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}/exception"

    - fileType: "Exception Handler"
      fileName: "GlobalExceptionHandler"
      extension: "java"
      content: |
        package ${groupLink}.${lowerCase(projectName)}.exception.handler;
        
        import ${groupLink}.${lowerCase(projectName)}.dto.RestResponse;
        import ${groupLink}.${lowerCase(projectName)}.exception.InternalServerErrorException;
        import ${groupLink}.${lowerCase(projectName)}.exception.ResourceNotFoundException;
        import org.springframework.http.HttpStatus;
        import org.springframework.http.ResponseEntity;
        import org.springframework.web.bind.annotation.ExceptionHandler;
        import org.springframework.web.bind.annotation.RestControllerAdvice;
        
        @RestControllerAdvice
        public class GlobalExceptionHandler {
            
            @ExceptionHandler(ResourceNotFoundException.class)
            public ResponseEntity<RestResponse<Void>> handleEntityNotFoundException(ResourceNotFoundException ex) {
                RestResponse<Void> response = RestResponse.buildErrorResponse(HttpStatus.NOT_FOUND, ex.getMessage(), null);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
            }
            
            @ExceptionHandler(InternalServerErrorException.class)
            public ResponseEntity<RestResponse<Void>> handleInternalServerErrorException(InternalServerErrorException ex) {
                RestResponse<Void> response = RestResponse.buildErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage(), null);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
            
            @ExceptionHandler(Exception.class)
            public ResponseEntity<RestResponse<Void>> handleGenericException(Exception ex) {
                RestResponse<Void> response = RestResponse.buildErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR, "An unexpected error occurred", null);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        
        }

      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}/exception/handler"


    - fileType: "ApplicationYml"
      fileName: "application"
      extension: "yml"
      content: |
        spring:
          application:
            name: ${toKebabCase(projectName)}
        {{#if useDB}}
          datasource:
            url: ${connectionString}
            username: ${databaseUsername}
            password: ${databasePassword}
          jpa:
            hibernate:
              ddl-auto: ${hibernateDdlAuto}
            properties:
              hibernate.format_sql: true
        {{/if}}
        
        server:
          port: ${projectPort}
          servlet:
            context-path: /${toKebabCase(projectName)}
        
        # Logs Configuration
        logging:
          level:
            root: ${loggingLevel}
            {{#if useDB}}org.hibernate.SQL: ${loggingLevel}{{/if}}
        
        {{#if useEurekaServer}}
        eureka:
          client:
            service-url:
              defaultZone: ${eurekaServerURL}
          instance:
            prefer-ip-address: true
            ip-address: $[spring.cloud.client.ip-address]
        management:
          endpoints:
            web:
              exposure:
                include: health,info
          endpoint:
            health:
              show-details: always
            info:
              enabled: true
          info:
            env:
              enabled: true
            java:
              enabled: true
            build:
              enabled: true
        info:
          app:
            name: $[spring.application.name]
            description: "${projectDescription}"
            version: "0.0.1-SNAPSHOT"
            technical:
              spring-boot:
                version: "${frameworkVersion}"
              server:
                port: $[server.port]
              database:
                url: $[spring.datasource.url]
                type: "${databaseType}"
        {{/if}}

      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/resources/"

  configurations:
    - name: "Logging Level"
      variableName: "loggingLevel"
      options:
        - "TRACE"
        - "DEBUG"
        - "INFO"
        - "WARN"
        - "ERROR"
        - "FATAL"
        - "OFF"
      defaultOption: "INFO"
    - name: "Framework Version"
      variableName: "frameworkVersion"
      options:
        - "3.3.6"
        - "3.2.12"
      defaultOption: "3.3.6"
    - name: "Hibernate Ddl Auto"
      variableName: "hibernateDdlAuto"
      options:
        - "create"
        - "create-drop"
        - "none"
        - "update"
      defaultOption: "none"

  eurekaClientConfigurations:
    - name: "Eureka Server URL"
      variableName: "eurekaServerURL"
      options:
        - "http://localhost:8761/eureka/"
      defaultOption: "http://localhost:8761/eureka/"

  dependencies:
    - groupId: "org.projectlombok"
      artifactId: "lombok"
      version: "1.18.36"
      scope: "provided"

    - groupId: "org.springframework.boot"
      artifactId: "spring-boot-starter-data-jpa"
      version: "{{removeLine}}"
      scope: "{{removeLine}}"

    - groupId: "org.springframework.boot"
      artifactId: "spring-boot-starter-web"
      version: "{{removeLine}}"
      scope: "{{removeLine}}"

    - groupId: "org.springframework.boot"
      artifactId: "spring-boot-starter-test"
      version: "{{removeLine}}"
      scope: "{{removeLine}}"

    - groupId: "org.springdoc"
      artifactId: "springdoc-openapi-starter-webmvc-ui"
      version: "2.6.0"
      scope: "{{removeLine}}"

  model:
    toGenerate: true
    modelImports: |
      import jakarta.persistence.*;
      import lombok.Getter;
      import lombok.Setter;
    modelExtends: ""
    modelAnnotations: |
      @Setter
      @Getter
      @Entity
      @Table(name="${tableName}")
    modelFieldContent: |
      {{tab}}{{#each fields}}
      {{tab}}{{#if this.isPrimaryKey}}
      {{tab}}@Id
      {{tab}}@GeneratedValue(strategy=GenerationType.IDENTITY)
      {{tab}}@Column(name="${this.columnName}"){{elseIf this.isForeignKey}}
      {{tab}}@ManyToOne
      {{tab}}@JoinColumn(name="${this.columnName}"){{else}}
      {{tab}}@Column(name="${this.columnName}"){{/if}}
      {{tab}}private ${this.type} ${this.name};{{#if !@last}}{{newline}}{{/if}}
      {{tab}}{{/each}}
    modelGetterSetter: "{{removeLine}}"
    modelConstructors: "{{removeLine}}"
    modelSavePath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}/models"
    modelPackage: "${groupLink}.${lowerCase(projectName)}.models;"
  modelDao:
    toGenerate: true
    modelDaoImports: |
      import org.springframework.data.jpa.repository.JpaRepository;
      import ${groupLink}.${lowerCase(projectName)}.models.${majStart(className)};

    modelDaoAnnotations: ""
    modelDaoClassKeyword: "public interface"
    modelDaoExtends: "extends JpaRepository<${majStart(className)}, ${pkColumnType}>"
    modelDaoName: "${majStart(className)}Repository"
    modelDaoFieldContent: "{{removeLine}}"
    modelDaoMethodContent: "{{removeLine}}"
    modelDaoConstructors: "{{removeLine}}"
    modelDaoSavePath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}/repositories"
    modelDaoPackage: "${groupLink}.${lowerCase(projectName)}.repositories;"
    modelDaoAdditionalFiles: [ ]
  service:
    toGenerate: true
    serviceImports: |
      import org.springframework.data.domain.Sort;
      import ${groupLink}.${lowerCase(projectName)}.models.${majStart(className)};
      import org.springframework.stereotype.Service;
      import ${groupLink}.${lowerCase(projectName)}.repositories.${majStart(className)}Repository;
      import java.util.List;
      import java.util.Optional;
      import ${groupLink}.${lowerCase(projectName)}.services.interfaces.${majStart(className)}Service;
      import ${groupLink}.${lowerCase(projectName)}.exception.ResourceNotFoundException;
      import ${groupLink}.${lowerCase(projectName)}.exception.InternalServerErrorException;

    serviceAnnotations: |
      @Service
    serviceClassKeyword: "public class"
    serviceExtends: "implements ${majStart(className)}Service"
    serviceName: "Default${majStart(className)}Service"
    serviceFieldContent: |
      {{tab}}private final ${majStart(className)}Repository ${minStart(className)}Repository;
    serviceConstructors: |
      {{tab}}public Default${majStart(className)}Service(${majStart(className)}Repository ${minStart(className)}Repository) {
      {{tab}}   this.${minStart(className)}Repository = ${minStart(className)}Repository;
      {{tab}}}
    serviceMethodContent: |
      {{tab}}@Override
      {{tab}}public List<${majStart(className)}> getAll${majStart(className)}() {
      {{tab}}    try {
      {{tab}}        return ${minStart(className)}Repository.findAll(Sort.by(Sort.Direction.ASC, "${pkColumn}"));
      {{tab}}    } catch (Exception ex) {
      {{tab}}        throw new InternalServerErrorException("Error while retrieving ${formatReadableLowerCase(className)}", ex);
      {{tab}}    }
      {{tab}}}
      
      {{tab}}@Override
      {{tab}}public ${majStart(className)} get${majStart(className)}ById(${pkColumnType} ${pkColumn}) {
      {{tab}}    Optional<${majStart(className)}> ${minStart(className)} = ${minStart(className)}Repository.findById(${pkColumn});
      {{tab}}    if (${minStart(className)}.isPresent()) {
      {{tab}}        return ${minStart(className)}.get();
      {{tab}}    } else {
      {{tab}}        throw new ResourceNotFoundException("${majStart(className)} not found with ${pkColumn} : " + ${pkColumn});
      {{tab}}    }
      {{tab}}}
      
      {{tab}}@Override
      {{tab}}public ${majStart(className)} create${majStart(className)}(${majStart(className)} ${minStart(className)}) {
      {{tab}}    try {
      {{tab}}        return ${minStart(className)}Repository.save(${minStart(className)});
      {{tab}}    } catch (Exception ex) {
      {{tab}}        throw new InternalServerErrorException("Error while creating ${formatReadableLowerCase(className)}", ex);
      {{tab}}    }
      {{tab}}}
      
      {{tab}}@Override
      {{tab}}public ${majStart(className)} update${majStart(className)}(${pkColumnType} ${pkColumn}, ${majStart(className)} ${minStart(className)}) {
      {{tab}}    Optional<${majStart(className)}> existing${majStart(className)} = ${minStart(className)}Repository.findById(${pkColumn});
      {{tab}}    if (existing${majStart(className)}.isPresent()) {
      {{tab}}        ${minStart(className)}.set${majStart(pkColumn)}(${pkColumn});
      {{tab}}        try {
      {{tab}}            return ${minStart(className)}Repository.save(${minStart(className)});
      {{tab}}        } catch (Exception ex) {
      {{tab}}            throw new InternalServerErrorException("Error while updating ${formatReadableLowerCase(className)}", ex);
      {{tab}}        }
      {{tab}}    } else {
      {{tab}}        throw new ResourceNotFoundException("${majStart(className)} not found with ${pkColumn} : " + ${pkColumn});
      {{tab}}    }
      {{tab}}}
      
      {{tab}}@Override
      {{tab}}public void delete${majStart(className)}(${pkColumnType} ${pkColumn}) {
      {{tab}}    try {
      {{tab}}        ${minStart(className)}Repository.deleteById(${pkColumn});
      {{tab}}    } catch (Exception ex) {
      {{tab}}        throw new InternalServerErrorException("Error while deleting ${formatReadableLowerCase(className)}", ex);
      {{tab}}    }
      {{tab}}}

    serviceSavePath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}/services"
    servicePackage: "${groupLink}.${lowerCase(projectName)}.services;"
    serviceAdditionalFiles:
      - fileType: "Interface service"
        fileName: "${majStart(className)}Service"
        extension: "java"
        content: |
          package ${groupLink}.${lowerCase(projectName)}.services.interfaces;
          
          import ${groupLink}.${lowerCase(projectName)}.models.${className};
          import java.util.List;
          
          public interface ${majStart(className)}Service {
              List<${className}> getAll${className}();
          
              ${className} get${className}ById(${pkColumnType} ${pkColumn});
          
              ${className} create${className}(${className} ${minStart(className)});
          
              ${className} update${className}(${pkColumnType} ${pkColumn}, ${className} ${minStart(className)});
          
              void delete${className}(${pkColumnType} ${pkColumn});
          }

        destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}/services/interfaces"

  controller:
    toGenerate: true
    controllerImports: |
      import io.swagger.v3.oas.annotations.Operation;
      import io.swagger.v3.oas.annotations.Parameter;
      import io.swagger.v3.oas.annotations.media.Content;
      import io.swagger.v3.oas.annotations.media.Schema;
      import io.swagger.v3.oas.annotations.responses.ApiResponse;
      import io.swagger.v3.oas.annotations.responses.ApiResponses;
      import io.swagger.v3.oas.annotations.tags.Tag;
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import ${groupLink}.${lowerCase(projectName)}.models.${majStart(className)};
      import org.springframework.web.bind.annotation.*;
      import ${groupLink}.${lowerCase(projectName)}.services.interfaces.${majStart(className)}Service;
      import ${groupLink}.${lowerCase(projectName)}.dto.RestResponse;

      import java.util.List;

    controllerAnnotations: |
      @RestController
      @RequestMapping("/${lowerCase(classNameLink)}")
      @Tag(name = "${formatReadable(className)}", description = "${formatReadable(className)} Management APIs")
    controllerExtends: ""
    controllerName: "${majStart(className)}Controller"
    controllerFieldContent: |
      {{tab}}private final ${majStart(className)}Service ${lowerCase(className)}Service;
    controllerConstructors: |
      {{tab}}public ${majStart(className)}Controller(${majStart(className)}Service ${lowerCase(className)}Service) {
      {{tab}}   this.${lowerCase(className)}Service = ${lowerCase(className)}Service;
      {{tab}}}
    controllerMethodContent: |
      {{tab}}@Operation(
      {{tab}}    summary = "Retrieve all ${formatReadableLowerCase(className)}",
      {{tab}}    description = "Get a list of all ${formatReadableLowerCase(className)} items. Returns an empty list if no data is found."
      {{tab}})
      {{tab}}@ApiResponses({
      {{tab}}    @ApiResponse(
      {{tab}}        responseCode = "200",
      {{tab}}        description = "Successfully retrieved the list of ${formatReadableLowerCase(className)}",
      {{tab}}        content = @Content(mediaType = "application/json", schema = @Schema(implementation = ApiResponse.class))
      {{tab}}    ),
      {{tab}}    @ApiResponse(
      {{tab}}        responseCode = "204",
      {{tab}}        description = "No ${formatReadableLowerCase(className)} found"
      {{tab}}    )
      {{tab}}})
      {{tab}}@GetMapping
      {{tab}}public ResponseEntity<RestResponse<List<${majStart(className)}>>> getAll${majStart(classNameLink)}() {
      {{tab}}    List<${majStart(className)}> ${lowerCase(classNameLink)} = ${lowerCase(className)}Service.getAll${majStart(className)}();
      {{tab}}    if (${lowerCase(classNameLink)}.isEmpty()) {
      {{tab}}        return ResponseEntity.noContent().build();
      {{tab}}    }
      {{tab}}    RestResponse<List<${majStart(className)}>> response = RestResponse.buildSuccessResponse(HttpStatus.OK,
      {{tab}}            "${formatReadableLowerCase(className)} retrieved successfully", ${lowerCase(classNameLink)});
      {{tab}}    return ResponseEntity.ok(response);
      {{tab}}}
      
      {{tab}}@Operation(
      {{tab}}    summary = "Get ${formatReadableLowerCase(className)} by ID",
      {{tab}}    description = "Retrieve a specific ${formatReadableLowerCase(className)} item by its ID"
      {{tab}})
      {{tab}}@ApiResponses({
      {{tab}}    @ApiResponse(
      {{tab}}        responseCode = "200",
      {{tab}}        description = "Successfully retrieved the ${formatReadableLowerCase(className)}",
      {{tab}}        content = @Content(mediaType = "application/json", schema = @Schema(implementation = ApiResponse.class))
      {{tab}}    ),
      {{tab}}    @ApiResponse(
      {{tab}}        responseCode = "404",
      {{tab}}        description = "${formatReadable(className)} not found with the provided ID"
      {{tab}}    )
      {{tab}}})
      {{tab}}@GetMapping("/{${pkColumn}}")
      {{tab}}public ResponseEntity<RestResponse<${majStart(className)}>> get${majStart(className)}ById(
      {{tab}}    @Parameter(description = "ID of the ${formatReadableLowerCase(className)} to retrieve", required = true)
      {{tab}}    @PathVariable ${pkColumnType} ${pkColumn}
      {{tab}}) {
      {{tab}}    ${majStart(className)} ${lowerCase(className)} = ${lowerCase(className)}Service.get${majStart(className)}ById(${pkColumn});
      {{tab}}    RestResponse<${majStart(className)}> response = RestResponse.buildSuccessResponse(HttpStatus.OK,
      {{tab}}            "${formatReadableLowerCase(className)} retrieved successfully", ${lowerCase(className)});
      {{tab}}    return ResponseEntity.ok(response);
      {{tab}}}
      
      {{tab}}@Operation(
      {{tab}}    summary = "Create new ${formatReadableLowerCase(className)}",
      {{tab}}    description = "Create a new ${formatReadableLowerCase(className)} item with the provided information"
      {{tab}})
      {{tab}}@ApiResponses({
      {{tab}}    @ApiResponse(
      {{tab}}        responseCode = "201",
      {{tab}}        description = "${formatReadable(className)} created successfully",
      {{tab}}        content = @Content(mediaType = "application/json", schema = @Schema(implementation = ApiResponse.class))
      {{tab}}    ),
      {{tab}}    @ApiResponse(
      {{tab}}        responseCode = "400",
      {{tab}}        description = "Invalid ${formatReadableLowerCase(className)} supplied"
      {{tab}}    )
      {{tab}}})
      {{tab}}@PostMapping
      {{tab}}public ResponseEntity<RestResponse<${majStart(className)}>> create${majStart(className)}(
      {{tab}}    @Parameter(description = "${formatReadable(className)} object to be created", required = true)
      {{tab}}    @RequestBody ${majStart(className)} ${lowerCase(className)}
      {{tab}}) {
      {{tab}}    ${majStart(className)} new${majStart(className)} = ${lowerCase(className)}Service.create${majStart(className)}(${lowerCase(className)});
      {{tab}}    RestResponse<${majStart(className)}> response = RestResponse.buildSuccessResponse(HttpStatus.CREATED,
      {{tab}}            "${formatReadableLowerCase(className)} created successfully", new${majStart(className)});
      {{tab}}    return ResponseEntity.status(HttpStatus.CREATED).body(response);
      {{tab}}}
      
      {{tab}}@Operation(
      {{tab}}    summary = "Update existing ${formatReadableLowerCase(className)}",
      {{tab}}    description = "Update an existing ${formatReadableLowerCase(className)} item with the provided information"
      {{tab}})
      {{tab}}@ApiResponses({
      {{tab}}    @ApiResponse(
      {{tab}}        responseCode = "200",
      {{tab}}        description = "${formatReadable(className)} updated successfully",
      {{tab}}        content = @Content(mediaType = "application/json", schema = @Schema(implementation = ApiResponse.class))
      {{tab}}    ),
      {{tab}}    @ApiResponse(
      {{tab}}        responseCode = "404",
      {{tab}}        description = "${formatReadable(className)} not found with the provided ID"
      {{tab}}    ),
      {{tab}}    @ApiResponse(
      {{tab}}        responseCode = "400",
      {{tab}}        description = "Invalid ${formatReadableLowerCase(className)} supplied"
      {{tab}}    )
      {{tab}}})
      {{tab}}@PutMapping("/{${pkColumn}}")
      {{tab}}public ResponseEntity<RestResponse<${majStart(className)}>> update${majStart(className)}(
      {{tab}}    @Parameter(description = "ID of the ${formatReadableLowerCase(className)} to update", required = true)
      {{tab}}    @PathVariable ${pkColumnType} ${pkColumn},
      {{tab}}    @Parameter(description = "Updated ${formatReadableLowerCase(className)} object", required = true)
      {{tab}}    @RequestBody ${majStart(className)} ${lowerCase(className)}
      {{tab}}) {
      {{tab}}    ${majStart(className)} update${majStart(className)} = ${lowerCase(className)}Service.update${majStart(className)}(${pkColumn}, ${lowerCase(className)});
      {{tab}}    RestResponse<${majStart(className)}> response = RestResponse.buildSuccessResponse(HttpStatus.OK,
      {{tab}}            "${formatReadableLowerCase(className)} updated successfully", update${majStart(className)});
      {{tab}}    return ResponseEntity.ok(response);
      {{tab}}}
      
      {{tab}}@Operation(
      {{tab}}    summary = "Delete ${formatReadableLowerCase(className)}",
      {{tab}}    description = "Delete a ${formatReadableLowerCase(className)} item by its ID"
      {{tab}})
      {{tab}}@ApiResponses({
      {{tab}}    @ApiResponse(
      {{tab}}        responseCode = "204",
      {{tab}}        description = "${formatReadable(className)} deleted successfully"
      {{tab}}    ),
      {{tab}}    @ApiResponse(
      {{tab}}        responseCode = "404",
      {{tab}}        description = "${formatReadable(className)} not found with the provided ID"
      {{tab}}    )
      {{tab}}})
      {{tab}}@DeleteMapping("/{${pkColumn}}")
      {{tab}}public ResponseEntity<RestResponse<Void>> delete${majStart(className)}ById(
      {{tab}}    @Parameter(description = "ID of the ${formatReadableLowerCase(className)} to delete", required = true)
      {{tab}}    @PathVariable ${pkColumnType} ${pkColumn}
      {{tab}}) {
      {{tab}}    ${lowerCase(className)}Service.delete${majStart(className)}(${pkColumn});
      {{tab}}    RestResponse<Void> response = RestResponse.buildSuccessResponse(HttpStatus.NO_CONTENT,
      {{tab}}            "${formatReadableLowerCase(className)} deleted successfully", null);
      {{tab}}    return ResponseEntity.ok(response);
      {{tab}}}


    controllerSavePath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}/controllers"
    controllerPackage: "${groupLink}.${lowerCase(projectName)}.controllers;"
    controllerAdditionalFiles: []

- id: 2
  languageId: 2
  coreFramework: ".NET"
  name: "ASP.NET Core - WEB API REST"
  template: "Template"
  useDB: true
  withGroupId: false
  useCloud: false
  useEurekaServer: false
  isGateway: false
  additionalFiles:
    - fileType: "ProgramFile"
      fileName: "Program"
      extension: "cs"
      content: |
        {{#if useEurekaServer}}
        using Steeltoe.Management.Endpoint.Info;
        using Steeltoe.Discovery.Client;
        using Steeltoe.Management.Endpoint.Health;
        using Steeltoe.Management.Endpoint;
        using System.Net.NetworkInformation;
        using System.Net.Sockets;{{/if}}
        using System.Net;
        using Microsoft.OpenApi.Models;
        using Microsoft.EntityFrameworkCore;
        using ${majStart(projectName)}.Data;
        using ${majStart(projectName)}.Repositories.Implementation;
        using ${majStart(projectName)}.Repositories.Interface;
        using ${majStart(projectName)}.Services.Implementation;
        using ${majStart(projectName)}.Services.Interface;
        
        var builder = WebApplication.CreateBuilder(args);
        
        var pathBase = builder.Configuration.GetValue<string>("PathBase");
        
        builder.Services.AddSwaggerGen(c =>
        {
            c.SwaggerDoc("v1", new OpenApiInfo
            {
                Title = "${projectName}",               
                Version = "v1",                       
                Description = "${projectDescription}"
            });
            if (!string.IsNullOrEmpty(pathBase))
            {
              c.AddServer(new OpenApiServer { Url = pathBase });
            }
        });
        
        // Configure Kestrel to listen on both the machine's IP address and localhost
        builder.WebHost.ConfigureKestrel(options =>
        {
            {{#if useEurekaServer}}
            options.Listen(IPAddress.Parse(localIpAddress), ${projectPort});{{/if}}
            options.Listen(IPAddress.Loopback, ${projectPort});
        });
        {{#if useEurekaServer}}
        
        // Add Steeltoe Actuators for application monitoring and diagnostics
        builder.Services.AddAllActuators(builder.Configuration);
        builder.Services.AddHealthActuator();
        builder.Services.AddInfoActuator();
        
        {{#if useEurekaServer}}
        // Retrieve the local IP address dynamically
        string localIpAddress = NetworkInterface
              .GetAllNetworkInterfaces()
              .SelectMany(nic => nic.GetIPProperties().UnicastAddresses)
              .Where(addr => addr.Address.AddressFamily == AddressFamily.InterNetwork && !IPAddress.IsLoopback(addr.Address))
              .Select(addr => addr.Address.ToString())
              .FirstOrDefault() ?? "127.0.0.1";
        
        // Set the IP address in configuration for Eureka registration
        builder.Configuration["eureka:instance:ipAddress"] = localIpAddress;
        
        // Add Eureka Discovery Client for service registration with Eureka server
        builder.Services.AddDiscoveryClient(builder.Configuration);{{/if}}
        
        // Add services to the container.
        var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
        builder.Services.AddDbContext<${majStart(projectName)}Context>(options =>
            options.Use${daoName}(connectionString${addOptions}));
        
        // Adding repositories ...
        {{#each entities}}
        builder.Services.AddScoped<I${this}Repository, ${this}Repository>();
        {{/each}}
        // Adding services ...
        {{#each entities}}
        builder.Services.AddScoped<I${this}Service, ${this}Service>();
        {{/each}}
        // Adding controllers ...
        builder.Services.AddControllers();
        
        // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
        builder.Services.AddEndpointsApiExplorer();
        builder.Services.AddSwaggerGen();
        
        var app = builder.Build();
        
        if (!string.IsNullOrEmpty(pathBase))
        {
            app.UsePathBase(pathBase);
        }
        
        // Configure the HTTP request pipeline.
        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }
        
        app.UseHttpsRedirection();
        {{#if useEurekaServer}}
        // Map all actuators and controllers directly
        app.MapAllActuators(_ => { });{{/if}}
        app.MapControllers();
        
        app.UseAuthorization();
        app.Run();
      

      destinationPath: "${destinationFolder}/${majStart(projectName)}/${majStart(projectName)}/"

    - fileType: "DbContextFile"
      fileName: "${majStart(projectName)}Context"
      extension: "cs"
      content: |
        namespace ${majStart(projectName)}.Data;
        
        using Microsoft.EntityFrameworkCore;
        using Models;
        
        public class ${majStart(projectName)}Context : DbContext
        {
            {{#each entities}}
            public DbSet<${this}> ${this}s { get; set; }
            {{/each}}
            public ${majStart(projectName)}Context(DbContextOptions<${majStart(projectName)}Context> options) : base(options)
            {
            }
        }
      destinationPath: "${destinationFolder}/${majStart(projectName)}/${majStart(projectName)}/Data/"

    - fileType: "Generic  file"
      fileName: "IRepository"
      extension: "cs"
      content: |
        namespace ${majStart(projectName)}.Repositories.Generic;
        
        using System.Linq.Expressions;
        
        public interface IRepository<T, in TKey> where T : class
        {
            Task<IEnumerable<T>> GetAllWithIncludes(params Expression<Func<T, object?>>[]? includeProperties);
            Task<T?> GetByIdAsync(TKey id, params Expression<Func<T, object?>>[]? includeProperties);
            Task AddAsync(T entity);
            Task UpdateAsync(T entity);
            Task DeleteAsync(TKey id);
            Task<bool> ExistsAsync(TKey id);
        }
      destinationPath: "${destinationFolder}/${majStart(projectName)}/${majStart(projectName)}/Repositories/Generic/"

    - fileType: "Generic Repository file"
      fileName: "Repository"
      extension: "cs"
      content: |
        namespace ${majStart(projectName)}.Repositories.Generic;
        
        using System.ComponentModel.DataAnnotations;
        using System.Linq.Expressions;
        using Microsoft.EntityFrameworkCore;
        using Data;
        
        public class Repository<T, TKey>: IRepository<T, TKey>, IDisposable, IAsyncDisposable where T : class
        {
        
            private readonly DbSet<T> _dbSet;
            private readonly ${majStart(projectName)}Context _context;
        
            public Repository(${majStart(projectName)}Context context)
            {
                _context = context;
                _dbSet = context.Set<T>();
            }
        
            public async ValueTask DisposeAsync()
            {
                await _context.DisposeAsync();
            }
        
            public void Dispose()
            {
                _context.Dispose();
            }
        
            public async Task<IEnumerable<T>> GetAllWithIncludes(params Expression<Func<T, object?>>[]? includeProperties)
            {
                var query = GetQuery(_dbSet, includeProperties);
                query = query.OrderBy(e => EF.Property<object>(e, GetKeyPropertyName()));
                return await query.ToListAsync();
            }     
        
            public async Task<T?> GetByIdAsync(TKey id, params Expression<Func<T, object?>>[]? includeProperties)
            {
                var keyPropertyName = GetKeyPropertyName();
                var query = GetQuery(_dbSet, includeProperties);
                return await query.FirstOrDefaultAsync(e => EF.Property<TKey>(e, keyPropertyName)!.Equals(id));
            }
        
            public async Task AddAsync(T entity)
            {
                await _dbSet.AddAsync(entity);
                await _context.SaveChangesAsync();
            }
        
            public async Task UpdateAsync(T entity)
            {
                _context.Entry(entity).State = EntityState.Modified;
                await _context.SaveChangesAsync();
            }
        
            public async Task DeleteAsync(TKey id)
            {
                var entity = await GetByIdAsync(id);
                if (entity == null) 
                    throw new KeyNotFoundException($"Entity with ID {id} not found.");
                _dbSet.Remove(entity);
                await _context.SaveChangesAsync();
            }
        
            public async Task<bool> ExistsAsync(TKey id)
            {
                if (EqualityComparer<TKey>.Default.Equals(id, default)) return false;
        
                var keyPropertyName = GetKeyPropertyName();
        
                if (string.IsNullOrEmpty(keyPropertyName))
                throw new InvalidOperationException($"No key property found for type {typeof(T).Name}");
        
                return await _dbSet.AnyAsync(e =>
                    EF.Property<TKey>(e, keyPropertyName) != null &&
                    EF.Property<TKey>(e, keyPropertyName)!.Equals(id));
            }
        
            private IQueryable<T> GetQuery(IQueryable<T> query, params Expression<Func<T, object?>>[]? includeProperties)
            {
                if (includeProperties != null)
                    foreach (var includeProperty in includeProperties)
                        query = query.Include(includeProperty);
        
                return query;
            }
        
            private string GetKeyPropertyName()
            {
                var keyProperty = typeof(T).GetProperties()
                    .FirstOrDefault(prop => Attribute.IsDefined(prop, typeof(KeyAttribute)));
        
                if (keyProperty == null)
                    throw new InvalidOperationException($"No key property found for type {typeof(T).Name}");
        
                return keyProperty.Name;
            }
        }

      destinationPath: "${destinationFolder}/${majStart(projectName)}/${majStart(projectName)}/Repositories/Generic/"

    - fileType: "Generic file"
      fileName: "IService"
      extension: "cs"
      content: |
        namespace ${majStart(projectName)}.Services.Generic;
        
        using System.Linq.Expressions;
        
        public interface IService<T, in TKey> where T : class
        {
            Task<IEnumerable<T>> GetAllAsync(params Expression<Func<T, object?>>[]? includeProperties);
            Task<T?> GetByIdAsync(TKey id, params Expression<Func<T, object?>>[]? includeProperties);
            Task AddAsync(T entity);
            Task UpdateAsync(T entity);
            Task DeleteAsync(TKey id);
            Task<bool> ExistsAsync(TKey id);
        }
      destinationPath: "${destinationFolder}/${majStart(projectName)}/${majStart(projectName)}/Services/Generic/"

  configurations:
    - name: "Logging Level"
      variableName: "loggingLevel"
      options:
        - "Trace"
        - "Debug"
        - "Information"
        - "Warning"
        - "Error"
        - "Critical"
        - "None"
      defaultOption: "Information"
    - name: "Framework Version"
      variableName: "frameworkVersion"
      options:
        - "8.0"
        - "7.0"
        - "6.0"
      defaultOption: "8.0"

  eurekaClientConfigurations:
    - name: "Eureka Server URL"
      variableName: "eurekaServerURL"
      options:
        - "http://localhost:8761/eureka/"
      defaultOption: "http://localhost:8761/eureka/"

  dependencies: [ ]

  model:
    toGenerate: true
    modelImports: |
      using System.ComponentModel.DataAnnotations;
      using System.ComponentModel.DataAnnotations.Schema;
    modelExtends: ""
    modelAnnotations: |
      [Table("${tableName}")]
    modelFieldContent: |
      {{tab}}{{#each fields}}{{#if this.isPrimaryKey}}
      {{tab}}[Key]
      {{tab}}[DatabaseGenerated(DatabaseGeneratedOption.Identity)]
      {{tab}}[Column("${this.columnName}")]
      {{tab}}public ${this.type} ${majStart(this.name)} { get; set; }{{elseIf this.isForeignKey}}
      {{tab}}
      {{tab}}[Column("${this.columnName}")]
      {{tab}}public ${this.referencedColumnType} ${majStart(this.columnNameField)} { get; set; }
      {{tab}}[ForeignKey(nameof(${majStart(this.columnNameField)}))]
      {{tab}}public virtual ${this.type}? ${majStart(this.name)} { get; set; }
      {{tab}}{{else}}
      {{tab}}[Column("${this.columnName}")]
      {{tab}}public ${this.type} ${majStart(this.name)} { get; set; }{{/if}}{{#if !@last}}{{newline}}{{/if}}
      {{tab}}{{/each}}
    modelGetterSetter: "{{removeLine}}"
    modelConstructors: "{{removeLine}}"
    modelSavePath: "${destinationFolder}/${majStart(projectName)}/${majStart(projectName)}/Models/"
    modelPackage: "${majStart(projectName)}.Models"
  modelDao:
    toGenerate: true
    modelDaoImports: |
      using Models;
      using Generic;

    modelDaoAnnotations: ""
    modelDaoClassKeyword: "public interface"
    modelDaoExtends: ": IRepository<${majStart(className)}, ${pkColumnType}>"
    modelDaoName: "I${majStart(className)}Repository"
    modelDaoFieldContent: "{{removeLine}}"
    modelDaoMethodContent: "{{removeLine}}"
    modelDaoConstructors: "{{removeLine}}"
    modelDaoSavePath: "${destinationFolder}/${majStart(projectName)}/${majStart(projectName)}/Repositories/Interface/"
    modelDaoPackage: "${majStart(projectName)}.Repositories.Interface"
    modelDaoAdditionalFiles:
      - fileType: "Repository inherited from Generic Repository"
        fileName: "${majStart(className)}Repository"
        extension: "cs"
        content: |
          using ${majStart(projectName)}.Data;
          using ${majStart(projectName)}.Models;
          using ${majStart(projectName)}.Repositories.Generic;
          using ${majStart(projectName)}.Repositories.Interface;
          
          namespace ${majStart(projectName)}.Repositories.Implementation;
          
          public class ${majStart(className)}Repository : Repository<${majStart(className)}, ${pkColumnType}>, I${majStart(className)}Repository          {
              public ${majStart(className)}Repository(${majStart(projectName)}Context context) : base(context)
              {
              }
          }
        destinationPath: "${destinationFolder}/${majStart(projectName)}/${majStart(projectName)}/Repositories/Implementation/"

  service:
    toGenerate: true
    serviceImports: |
      using Models;
      using Generic;

    serviceAnnotations: ""
    serviceClassKeyword: "public interface"
    serviceExtends: ": IService<${majStart(className)}, ${pkColumnType}>"
    serviceName: "I${majStart(className)}Service"
    serviceFieldContent: "{{removeLine}}"
    serviceMethodContent: "{{removeLine}}"
    serviceConstructors: "{{removeLine}}"
    serviceSavePath: "${destinationFolder}/${majStart(projectName)}/${majStart(projectName)}/Services/Interface"
    servicePackage: "${majStart(projectName)}.Services.Interface"
    serviceAdditionalFiles:
      - fileType: "Service inherited from Service Interface"
        fileName: "${majStart(className)}Service"
        extension: "cs"
        content: |
          using System.Linq.Expressions;
          using ${majStart(projectName)}.Models;
          using ${majStart(projectName)}.Repositories.Interface;
          using ${majStart(projectName)}.Repositories.Implementation;
          using ${majStart(projectName)}.Services.Interface;
          
          namespace ${majStart(projectName)}.Services.Implementation;
          
          public class ${majStart(className)}Service : I${majStart(className)}Service
          {
              private readonly I${majStart(className)}Repository _repository;
          
              public ${majStart(className)}Service(I${majStart(className)}Repository repository)
              {
                  _repository = repository;
              }
          
              public async Task<IEnumerable<${majStart(className)}>> GetAllAsync(params Expression<Func<${majStart(className)}, object?>>[]? includeProperties)
              {
                  return await _repository.GetAllWithIncludes(includeProperties);
              }
          
              public async Task<${majStart(className)}?> GetByIdAsync(${pkColumnType} id, params Expression<Func<${majStart(className)}, object?>>[]? includeProperties)
              {
                  return await _repository.GetByIdAsync(id, includeProperties);
              }
          
              public async Task AddAsync(${majStart(className)} ${minStart(className)})
              {
                  await _repository.AddAsync(${minStart(className)});
              }
          
              public async Task UpdateAsync(${majStart(className)} ${minStart(className)})
              {
                  await _repository.UpdateAsync(${minStart(className)});
              }
          
              public async Task DeleteAsync(${pkColumnType} id)
              {
                  await _repository.DeleteAsync(id);
              }
          
              public async Task<bool> ExistsAsync(${pkColumnType} id)
              {
                  return await _repository.ExistsAsync(id);
              }
          }
        destinationPath: "${destinationFolder}/${majStart(projectName)}/${majStart(projectName)}/Services/Implementation/"

  controller:
    toGenerate: true
    controllerImports: |
      using Microsoft.AspNetCore.Mvc;
      using Models;
      using Services;
      using Services.Interface;

    controllerAnnotations: |
      [ApiController]
      [Route("${minStart(className)}s")]
    controllerExtends: " : ControllerBase"
    controllerName: "${majStart(className)}Controller"
    controllerFieldContent: |
      {{tab}}private readonly I${majStart(className)}Service _service;
    controllerConstructors: |
      {{tab}}public ${majStart(className)}Controller(I${majStart(className)}Service service)
      {{tab}}{
      {{tab}}{{tab}}_service = service;
      {{tab}}}
    controllerMethodContent: |
      {{tab}}[HttpGet]
      {{tab}}public async Task<ActionResult<IEnumerable<${majStart(className)}>>> Get${majStart(className)}s()
      {{tab}}{
      {{tab}}{{tab}}var ${minStart(className)}s = await _service.GetAllAsync({{#each fieldsFK}}e => e.${majStart(this.name)}{{#if !@last}}, {{/if}}{{/each}});
      {{tab}}{{tab}}return ${minStart(className)}s.Any() ? Ok(${minStart(className)}s) : NoContent();
      {{tab}}}
      
      {{tab}}[HttpGet("{id}")]
      {{tab}}public async Task<ActionResult<${majStart(className)}>> Get${majStart(className)}(${pkColumnType} id)
      {{tab}}{
      {{tab}}{{tab}}var ${minStart(className)} = await _service.GetByIdAsync(id{{#each fieldsFK}}, e => e.${majStart(this.name)}{{/each}});
      {{tab}}{{tab}}return ${minStart(className)} == null ? NotFound() : Ok(${minStart(className)});
      {{tab}}}
      
      {{tab}}[HttpPost]
      {{tab}}public async Task<ActionResult<${majStart(className)}>> Post(${majStart(className)} ${minStart(className)})
      {{tab}}{
      {{tab}}{{tab}}await _service.AddAsync(${minStart(className)});
      {{tab}}{{tab}}return CreatedAtAction(nameof(Get${majStart(className)}), new { id = ${minStart(className)}.${majStart(pkColumn)} }, ${minStart(className)});
      {{tab}}}
      
      {{tab}}[HttpPut("{id}")]
      {{tab}}public async Task<ActionResult<${majStart(className)}>> Put${majStart(className)}(${pkColumnType} id, ${majStart(className)} ${minStart(className)})
      {{tab}}{
      {{tab}}{{tab}}if (id != ${minStart(className)}.${majStart(pkColumn)})
      {{tab}}{{tab}}{{tab}}return BadRequest();
      
      {{tab}}{{tab}}var exists = await _service.ExistsAsync(id);
      {{tab}}{{tab}}if (!exists) return NotFound();
      
      {{tab}}{{tab}}await _service.UpdateAsync(${minStart(className)});
      {{tab}}{{tab}}return NoContent();
      {{tab}}}
      
      {{tab}}[HttpDelete("{id}")]
      {{tab}}public async Task<ActionResult> Delete${majStart(className)}(${pkColumnType} id)
      {{tab}}{
      
      {{tab}}{{tab}}var exists = await _service.ExistsAsync(id);
      {{tab}}{{tab}}if (!exists) return NotFound();
      
      {{tab}}{{tab}}await _service.DeleteAsync(id);
      {{tab}}{{tab}}return NoContent();
      {{tab}}}

    controllerSavePath: "${destinationFolder}/${majStart(projectName)}/${majStart(projectName)}/Controllers"
    controllerPackage: "${majStart(projectName)}.Controllers"
    controllerAdditionalFiles: [ ]


- id: 3
  languageId: 1
  coreFramework: "Spring Boot"
  name: "Spring Boot - Eureka Server"
  template: "Template"
  useDB: false
  useCloud: true
  useEurekaServer: false
  isGateway: false
  withGroupId: true
  additionalFiles:
    - fileType: "MainFile"
      fileName: "${majStart(projectName)}Application"
      extension: "java"
      content: |
        package ${groupLink}.${lowerCase(projectName)};
        
        import org.springframework.boot.SpringApplication;
        import org.springframework.boot.autoconfigure.SpringBootApplication;
        import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;
        
        @EnableEurekaServer
        @SpringBootApplication
        public class ${majStart(projectName)}Application {
        {{tab}}public static void main(String[] args) {
        {{tab}}{{tab}}SpringApplication.run(${majStart(projectName)}Application.class, args);
        {{tab}}}
        }
      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}"

    - fileType: "TestFile"
      fileName: "${majStart(projectName)}ApplicationTests"
      extension: "java"
      content: |
        package ${groupLink}.${lowerCase(projectName)};
        
        import org.junit.jupiter.api.Test;
        import org.springframework.boot.test.context.SpringBootTest;
        
        @SpringBootTest
        class ${majStart(projectName)}ApplicationTests {
        
        {{tab}}@Test
        {{tab}}void contextLoads() {
        {{tab}}}
        
        }
      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/test/java/${groupLinkPath}/${lowerCase(projectName)}/"

    - fileType: "ApplicationYml"
      fileName: "application"
      extension: "yml"
      content: |
        spring:
          application:
            name: ${toKebabCase(projectName)}
        
        eureka:
          client:
            register-with-eureka: ${useEurekaServer}
            fetch-registry: ${useEurekaServer}
        {{#if useEurekaServer}}
            service-url:
              defaultZone: ${eurekaServerURL}
        
          instance:
              prefer-ip-address: true
              ip-address: $[spring.cloud.client.ip-address]
        
        management:
          endpoints:
            web:
              exposure:
                include: health,info
          endpoint:
            health:
              show-details: always
            info:
              enabled: true
          info:
            env:
              enabled: true
            java:
              enabled: true
            build:
              enabled: true
        info:
          app:
            name: $[spring.application.name]
            description: "${projectDescription}"
            version: "0.0.1-SNAPSHOT"
            technical:
              spring-boot:
                version: "${frameworkVersion}"
              server:
                port: $[server.port]
        {{/if}}
        server:
          port: ${projectPort}
        
        logging:
          level:
            eureka: ${loggingLevel}
            root: ${loggingLevel}
      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/resources/"

  configurations:
    - name: "Logging Level"
      variableName: "loggingLevel"
      options:
        - "TRACE"
        - "DEBUG"
        - "INFO"
        - "WARN"
        - "ERROR"
        - "FATAL"
        - "OFF"
      defaultOption: "INFO"
    - name: "Framework Version"
      variableName: "frameworkVersion"
      options:
        - "3.3.6"
        - "3.2.12"
      defaultOption: "3.3.6"

  eurekaClientConfigurations:
    - name: "Eureka Server URL"
      variableName: "eurekaServerURL"
      options:
        - "http://localhost:8761/eureka/"
      defaultOption: "http://localhost:8761/eureka/"


  dependencies:
    - groupId: "org.springframework.cloud"
      artifactId: "spring-cloud-starter-netflix-eureka-server"
      version: "{{removeLine}}"
      scope: "{{removeLine}}"
    - groupId: "org.springframework.boot"
      artifactId: "spring-boot-starter-test"
      version: "{{removeLine}}"
      scope: "test"

- id: 4
  languageId: 1
  coreFramework: "Spring Boot"
  name: "Spring Boot - API Gateway"
  template: "Template"
  useDB: false
  useCloud: true
  useEurekaServer: false
  isGateway: true
  withGroupId: true
  additionalFiles:
    - fileType: "MainFile"
      fileName: "${majStart(projectName)}Application"
      extension: "java"
      content: |
        package ${groupLink}.${lowerCase(projectName)};
        
        import org.springframework.boot.SpringApplication;
        import org.springframework.boot.autoconfigure.SpringBootApplication;
        {{#if useEurekaServer}}import org.springframework.cloud.client.discovery.EnableDiscoveryClient;{{/if}}
        
        {{#if useEurekaServer}}@EnableDiscoveryClient{{/if}}
        @SpringBootApplication
        public class ${majStart(projectName)}Application {
            public static void main(String[] args) {
              SpringApplication.run(${majStart(projectName)}Application.class, args);
          }
        }

      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}"

    - fileType: "TestFile"
      fileName: "${majStart(projectName)}ApplicationTests"
      extension: "java"
      content: |
        package ${groupLink}.${lowerCase(projectName)};
        
        import org.junit.jupiter.api.Test;
        import org.springframework.boot.test.context.SpringBootTest;
        
        @SpringBootTest
        class ${majStart(projectName)}ApplicationTests {
        
            @Test
            void contextLoads() {
            }
        }
      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/test/java/${groupLinkPath}/${lowerCase(projectName)}/"

    - fileType: "SecurityConfig"
      fileName: "SecurityConfig"
      extension: "java"
      content: |
        package ${groupLink}.${lowerCase(projectName)}.config;
        
        import org.springframework.beans.factory.annotation.Value;
        import org.springframework.context.annotation.Bean;
        import org.springframework.context.annotation.Configuration;
        import org.springframework.security.config.Customizer;
        import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
        import org.springframework.security.config.web.server.ServerHttpSecurity;
        import org.springframework.security.core.userdetails.MapReactiveUserDetailsService;
        import org.springframework.security.core.userdetails.User;
        import org.springframework.security.core.userdetails.UserDetails;
        import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
        import org.springframework.security.crypto.password.PasswordEncoder;
        import org.springframework.security.web.server.SecurityWebFilterChain;
        
        @Configuration
        @EnableWebFluxSecurity
        public class SecurityConfig {
            @Value("$[security.user.username:admin]")
            private String username;
        
            @Value("$[security.user.password:admin]")
            private String password;
        
            @Value("$[security.user.role:USER]")
            private String role;
        
            @Bean
            public MapReactiveUserDetailsService userDetailsService() {
                UserDetails user = User.builder()
                    .username(username)
                    .password(passwordEncoder().encode(password))
                    .roles(role)
                    .build();
        
                return new MapReactiveUserDetailsService(user);
            }
        
            @Bean
            public PasswordEncoder passwordEncoder() {
                return new BCryptPasswordEncoder();
            }
        
            @Bean
            public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
                http.authorizeExchange(exchanges -> exchanges
                    .anyExchange().authenticated()
                ).httpBasic(Customizer.withDefaults());
        
              return http.build();
            }
        }

      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/java/${groupLinkPath}/${lowerCase(projectName)}/config"

    - fileType: "ApplicationYml"
      fileName: "application"
      extension: "yml"
      content: |
        server:
          port: ${projectPort}
        
        security:
          user:
            username: ${username}
            password: ${password}
            role: ${toUpperCase(role)}
        
        spring:
          main:
            web-application-type: reactive
          application:
            name: ${toKebabCase(projectName)}
        
          cloud:
            gateway:
              routes:
              {{#each routes}}
              - id: ${this.id}
                uri: ${this.uri}
                predicates:
                  - Path=${this.path}
                  - Method=${this.method}
        
              {{/each}}{{#if useEurekaServer}}
        eureka:
          client:
            service-url:
              defaultZone: ${eurekaServerURL}
          instance:
            prefer-ip-address: true
            ip-address: $[spring.cloud.client.ip-address]
        
        management:
          endpoints:
            web:
              exposure:
                include: health,info
          endpoint:
            health:
              show-details: always
            info:
              enabled: true
          info:
            env:
              enabled: true
            java:
              enabled: true
            build:
              enabled: true
        info:
          app:
            name: $[spring.application.name]
            description: "${projectDescription}"
            version: "0.0.1-SNAPSHOT"
            technical:
              spring-boot:
                version: "${frameworkVersion}"
              server:
                port: $[server.port]
        {{/if}}
        logging:
          level:
            root: ${loggingLevel}
            org.springframework.cloud.gateway: ${loggingLevel}

      destinationPath: "${destinationFolder}/${majStart(projectName)}/src/main/resources/"

  configurations:
    - name: "Logging Level"
      variableName: "loggingLevel"
      options:
        - "TRACE"
        - "DEBUG"
        - "INFO"
        - "WARN"
        - "ERROR"
        - "FATAL"
        - "OFF"
      defaultOption: "INFO"
    - name: "Framework Version"
      variableName: "frameworkVersion"
      options:
        - "3.3.6"
        - "3.2.12"
      defaultOption: "3.3.6"

  eurekaClientConfigurations:
    - name: "Eureka Server URL"
      variableName: "eurekaServerURL"
      options:
        - "http://localhost:8761/eureka/"
      defaultOption: "http://localhost:8761/eureka/"


  dependencies:
    - groupId: "org.springframework.cloud"
      artifactId: "spring-cloud-starter-gateway"
      version: "{{removeLine}}"
      scope: "{{removeLine}}"
    - groupId: "org.springframework.boot"
      artifactId: "spring-boot-starter-test"
      version: "{{removeLine}}"
      scope: "test"
    - groupId: "org.springframework.boot"
      artifactId: "spring-boot-starter-webflux"
      version: "{{removeLine}}"
      scope: "{{removeLine}}"
    - groupId: "io.projectreactor"
      artifactId: "reactor-test"
      version: "{{removeLine}}"
      scope: "test"
    - groupId: "org.springframework.boot"
      artifactId: "spring-boot-starter-security"
      version: "{{removeLine}}"
      scope: "{{removeLine}}"
